This is a note to self. To be persisted somewhere in a better form.

# references and dataclasses

In the Python domain we respect the Python semantics, including its typing. We make sure that if a user uses Python type
annotations, they actually get that type.

In the DSL domain we represent `Reference[MyDataclass]` as `MyDataclass` with reference attributes.

`Reference[MyDataclass]` can only be created in the Python domain, since it doesn't really exist in the inmanta domain. When
returned from a plugin, we create a model instance of `MyDataClass`, and set the attributes to all attribute references on top
of the python `Reference[MyDataclass]`. We link the original python reference on the instance object.

Because of this duality in the DSL domain, we consider it important that model dataclasses that stem from a plugin returning
`Reference[MyDataclass]`, and dataclasses with reference attributes constructed directly in the model, are somewhat compatible.
Most relevant is the case where `MyDataclass` supports references for all its attributes, according to its Python definition.
In that case, we can safely coerce a `Reference[MyDataclass]` to `MyDataclass` with reference attributes, even on the Python
side. This allows model instances that look and behave the same on the model side, to have the same behavior on the plugin
boundary as well. The other direction, to coerce a model-constructed `MyDataclass` consisting of references to
`Reference[MyDataclass]` would be a lot more involved, because the attribute references are not necessarily derived from a
single reference, as in the real `Reference[MyDataclass]` case. We will not implement coercion in that direction, at least
until a strong use case pops up.

Concretely, we will make sure that a plugin that accepts `MyDataclass` as a parameter, will coerce a `Reference[MyDataclass]`
if both required and possible.
- Required: we coerce if the plugin declares it must be `MyDataclass`, not for `MyDataclass | Reference[MyDataclass]`
- Possible: we can not coerce if the Python dataclass does not support references in all its attributes. In this case,
    we raise a type error stating that a `Reference[MyDataclass] was provided where `MyDataclass` was expected. As we would
    for any other reference type (e.g. `Reference[int]` passed to parameter declared as `int`).

If a user tries to pass a model-constructed `MyDataclass` to a plugin that accepts `MyDataclass`, but the model instance has
a reference attribute where the Python dataclass does not declare it, we also raise a type error on the plugin boundary, because
this instance can not be represented in the Python domain without violating the Python semantics, on which the plugin or other
parts of the Python code may rely.


# relation to dataclass on non-dataclass instance

When a non-dataclass instance is passed to the plugin domain, it will be represented as a `DynamicProxy` there. When a relation
attribute is accessed on it, it will contain a (or multiple) `DynamicProxy` as well, even if the relation is towards a
dataclass. The rationale is that this needs to be consistent and reliable. We will only ever instantiate dataclasses in the
Python domain when explicitly declared on the plugin boundary by annotating with the dataclass type rather than a model entity
type.

There may be some flexibility in this. It wouldn't be too strange to get elements of a different type, since the same goes for
attributes. Most relevant is that we don't get top-level dataclasses on `std::Entity` parameters etc. In relations, perhaps we
can afford to get them. But current implementation is as described above.


# reference attributes

When a non-dataclass instance has a reference attribute, and this attribute is accessed from the plugin domain
(`DynamicProxy.__getattr__()`), we want to get a `Reference`, not a `DynamicProxy` wrapping a `Reference`.
References live in the Python domain, so we should expose them as such.


TODO: why no indexes for dataclasses: makes references in relations very difficult, because you can never know if it might compact the list, which may affect `len`, iteration, arity, ...
TODO: object means any non-magic DSL value. Those need to be explicit. But only top-level, below that: black box and you're on your own
TODO: expand "reference attributes" section to mean any black box
