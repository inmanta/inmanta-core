diff --git a/src/inmanta/env.py b/src/inmanta/env.py
index c6e45eaa..7b4e8e57 100644
--- a/src/inmanta/env.py
+++ b/src/inmanta/env.py
@@ -28,14 +28,16 @@ import sys
 import tempfile
 import venv
 from dataclasses import dataclass
+from collections import abc
 from importlib.abc import Loader
 from importlib.machinery import ModuleSpec
 from itertools import chain
+from functools import reduce
 from subprocess import CalledProcessError
 from typing import Any, Dict, Iterator, List, Optional, Pattern, Sequence, Set, Tuple, TypeVar
 
 import pkg_resources
-from pkg_resources import DistInfoDistribution, Requirement
+from pkg_resources import Distribution, Requirement
 
 from inmanta import const
 from inmanta.ast import CompilerException
@@ -86,6 +88,43 @@ class PythonWorkingSet:
     def rebuild_working_set(cls) -> None:
         pkg_resources.working_set = pkg_resources.WorkingSet._build_master()
 
+    @classmethod
+    def get_dependency_tree(cls, dists: abc.Iterable[str]) -> abc.Set[str]:
+        """
+        Returns the full set of all dependencies (both direct and transitive) for the given distributions. Includes the
+        distributions themselves.
+        If one of the distributions or its dependencies is not installed, it is still included in the set but its dependencies
+        are not.
+
+        :param dists: The keys for the distributions to get the dependency tree for.
+        """
+        # create dict for O(1) lookup
+        installed_distributions: abc.Mapping[str, Distribution] = {
+            dist_info.key: dist_info
+            for dist_info in pkg_resources.working_set
+        }
+
+        def _get_tree_recursive(dists: abc.Iterable[str], acc: abc.Set[str] = frozenset()) -> abc.Set[str]:
+            """
+            :param acc: Accumulator for requirements that have already been recursed on.
+            """
+            return reduce(_get_tree_recursive_single, dists, acc)
+
+        def _get_tree_recursive_single(acc: abc.Set[str], dist: str) -> abc.Set[str]:
+            if dist in acc:
+                return acc
+
+            if dist not in installed_distributions:
+                return acc | {dist}
+
+            # recurse on direct dependencies if they have not yet been recursed on in a previous iteration
+            return _get_tree_recursive(
+                (requirement.key for requirement in installed_distributions[dist].requires()),
+                acc=acc | {dist},
+            )
+
+        return _get_tree_recursive(dists)
+
 
 @dataclass
 class LocalPackagePath:
@@ -623,23 +662,30 @@ class ActiveEnv(PythonEnvironment):
         :param constraints: In addition to checking for compatibility within the environment, also verify that the environment's
             packages meet the given constraints. All listed packages are expected to be installed.
         """
-        # add all requirements of all in scope packages installed in this environment
-        if not constraints:
-            constraints = []
-        inmanta_requirements: Set[str] = set([requirement.key for requirement in cls._get_requirements_on_inmanta_package()])
-
-        full_strict_scope: Set[str] = set([constraint.key for constraint in constraints] if constraints is not None else [])
-        all_constraints: Set[Requirement] = set(constraints if constraints is not None else [])
+        # all requirements of all packages installed in this environment
+        installed_constraints: abc.Set[Requirement] = frozenset(
+            requirement
+            for dist_info in pkg_resources.working_set
+            for requirement in dist_info.requires()
+        )
+        inmanta_constraints: abc.Set[Requirement] = frozenset(cls._get_requirements_on_inmanta_package())
+        extra_constraints: abc.Set[Requirement] = frozenset(constraints if constraints is not None else [])
+        all_constraints: abc.Set[Requirement] = installed_constraints | inmanta_constraints | all_constraints
 
-        dist_info: DistInfoDistribution
-        for dist_info in pkg_resources.working_set:
-            requires = [requirement for requirement in dist_info.requires()]
-            package = Requirement.parse(f"{dist_info.key}=={dist_info.version}")
-            if strict_scope.fullmatch(dist_info.key) or dist_info.key in inmanta_requirements or dist_info.key in constraints:
-                full_strict_scope.add(package.key)
-                full_strict_scope.update([require.key for require in requires])
-            all_constraints.add(package)
-            all_constraints.update(requires)
+        direct_full_scope_constrained: abc.Set[str] = frozenset(
+            requirement.key for requirement in chain(inmanta_constraints, extra_constraints)
+        )
+        full_strict_scope: abc.Set[str] = PythonWorkingSet.get_dependency_tree(
+            chain(
+                (
+                    []
+                    if strict_scope is None
+                    else (dist_info.key for dist_info in pkg_resources.working_set if strict_scope.fullmatch(dist_info.key))
+                ),
+                (requirement.key for requirement in inmanta_constraints),
+                (requirement.key for requirement in extra_constraints),
+            )
+        )
 
         installed_versions: Dict[str, version.Version] = PythonWorkingSet.get_packages_in_working_set()
 
@@ -660,7 +706,7 @@ class ActiveEnv(PythonEnvironment):
         for constraint, v in constraint_violations:
             LOGGER.warning("Incompatibility between constraint %s and installed version %s", constraint, v)
 
-    def _get_all_requires(dist_info: DistInfoDistribution):
+    def _get_all_requires(dist_info: Distribution):
         return
 
     @classmethod
