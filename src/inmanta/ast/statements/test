    def __init__(
        self,
        class_type: LocatableString,
        attributes: List[Tuple[LocatableString, ExpressionStatement]],
        wrapped_kwargs: List["WrappedKwargs"],
        location: Location,
        namespace: Namespace,
    ) -> None:
        super().__init__()
        self.class_type = class_type
        self.__attributes = {}  # type: Dict[str,ExpressionStatement]
        self.__attribute_locations: Dict[str, LocatableString] = {}
        self.__wrapped_kwarg_attributes: List[WrappedKwargs] = wrapped_kwargs
        self.location = location
        self.namespace = namespace
        self.anchors.append(TypeReferenceAnchor(namespace, class_type))
        for a in attributes:
            self.add_attribute(a[0], a[1])
        self.type: Optional["Entity"] = None
        self._self_ref: "Reference" = Reference(
            LocatableString(str(uuid.uuid4()), Range("__internal__", 1, 1, 1, 1), -1, self.namespace)
        )
        self._lhs_attribute: Optional[AttributeAssignmentLHS] = None
        self._required_dynamic_args: list[str] = []  # index attributes required from kwargs or lhs_attribute

        self._direct_attributes = {}  # type: Dict[str,ExpressionStatement]
        self._indirect_attributes = {}  # type: Dict[str,ExpressionStatement]

    def _normalize_rhs(self, index_attributes: abc.Set[str]) -> None:
        assert self.type is not None  # Make mypy happy
        for k, v in self.__attributes.items():
            attr = self.type.get_attribute(k)
            if attr is None:
                raise TypingException(
                    self.__attribute_locations[k], "no attribute %s on type %s" % (k, self.type.get_full_name())
                )
            type_hint = attr.get_type().get_base_type()
            # don't notify the rhs for index attributes because it won't be able to resolve the reference
            # (index attributes need to be resolved before the instance can be constructed)
            v.normalize(
                lhs_attribute=AttributeAssignmentLHS(self._self_ref, k, type_hint) if k not in index_attributes else None
            )
        for wrapped_kwargs in self.wrapped_kwargs:
            wrapped_kwargs.normalize()

    def normalize(self, *, lhs_attribute: Optional[AttributeAssignmentLHS] = None) -> None:
        self.type = self._resolve_type(lhs_attribute)

        inindex: abc.MutableSet[str] = set()

        all_attributes = dict(self.type.get_default_values())
        all_attributes.update(self.__attributes)

        # now check that all variables that have indexes on them, are already
        # defined and add the instance to the index
        for index in self.type.get_indices():
            for attr in index:
                if attr not in all_attributes:
                    self._required_dynamic_args.append(attr)
                    continue
                inindex.add(attr)

        if self._required_dynamic_args:
            self._lhs_attribute = lhs_attribute
            if not self.wrapped_kwargs and (self._lhs_attribute is None or len(self._required_dynamic_args) > 1):
                raise IndexAttributeMissingInConstructorException(self, self.type, self._required_dynamic_args)

        self._normalize_rhs(inindex)

        for k, v in all_attributes.items():
            attribute = self.type.get_attribute(k)
            if attribute is None:
                raise TypingException(
                    self.__attribute_locations[k], "no attribute %s on type %s" % (k, self.type.get_full_name())
                )
            if k not in inindex:
                self._indirect_attributes[k] = v
            else:
                self._direct_attributes[k] = v

        self._own_eager_promises = list(
            chain.from_iterable(subconstructor.get_all_eager_promises() for subconstructor in self.type.get_sub_constructor())
        )

    def _resolve_type(self, lhs_attribute: Optional[AttributeAssignmentLHS]) -> "Entity":

        # First normal resolution
        resolver_failure: Optional[TypeNotFoundException] = None
        local_type: "Optional[Entity]" = None
        try:
            tp = self.namespace.get_type(self.class_type)
            assert isinstance(
                tp, inmanta.ast.entity.Entity
            ), "Should not happen because all entity types start with a capital letter"
            local_type = tp
        except TypeNotFoundException as e:
            resolver_failure = e

        if lhs_attribute is not None and lhs_attribute.type_hint is not None:
            type_hint = lhs_attribute.type_hint
            if not isinstance(type_hint, inmanta.ast.entity.Entity):
                raise TypingException(
                    self,
                    f"Can not assign a value of type {self.class_type} "
                    f"to a variable of type {str(lhs_attribute.type_hint)}",
                )
            elif local_type is not None:
                if not type_hint.is_subclass(local_type, strict=False):
                    raise TypingException(
                        self,
                        f"Can not assign a value of type {str(local_type)} "
                        f"to a variable of type {str(lhs_attribute.type_hint)}",
                    )
                return local_type
            elif "::" not in str(self.class_type):
                base_types = [type_hint]
                candidates = {
                    entity
                    for entity in chain(base_types, type_hint.get_all_child_entities())
                    if entity.name == str(self.class_type)
                }
                if len(candidates) > 1:
                    # To many options, inheritance may cause this to break a working model due to dependency update
                    raise AmbiguousTypeException(self.class_type, list(candidates))
                elif len(candidates) == 1:
                    # One, nice
                    return next(iter(candidates))
        elif local_type is not None:
            return local_type

        assert resolver_failure is not None  # make mypy happy
        raise resolver_failure

    def get_all_eager_promises(self) -> Iterator["StaticEagerPromise"]:
        return chain(
            super().get_all_eager_promises(),
            *(subexpr.get_all_eager_promises() for subexpr in chain(self.attributes.values(), self.wrapped_kwargs)),
        )

    def requires(self) -> List[str]:
        out = [req for (k, v) in self.__attributes.items() for req in v.requires()]
        out.extend(req for kwargs in self.__wrapped_kwarg_attributes for req in kwargs.requires())
        out.extend(req for (k, v) in self.get_default_values().items() for req in v.requires())
        return out

    def requires_emit(self, resolver: Resolver, queue: QueueScheduler) -> Dict[object, VariableABC[object]]:
        requires: Dict[object, VariableABC[object]] = super().requires_emit(resolver, queue)
        direct = [x for x in self._direct_attributes.items()]

        direct_requires = {rk: rv for (k, v) in direct for (rk, rv) in v.requires_emit(resolver, queue).items()}
        direct_requires.update(
            {rk: rv for kwargs in self.__wrapped_kwarg_attributes for (rk, rv) in kwargs.requires_emit(resolver, queue).items()}
        )
        if self._lhs_attribute is not None:
            direct_requires.update(
                self._lhs_attribute.instance.requires_emit(resolver, queue)
            )
        requires.update(direct_requires)

        graph: Optional[DataflowGraph] = resolver.dataflow_graph
        if graph is not None:
            node: dataflow.InstanceNodeReference = self._register_dataflow_node(graph)
            for k, v in chain(self._direct_attributes.items(), self._indirect_attributes.items()):
                node.assign_attribute(k, v.get_dataflow_node(graph), self, graph)

        return requires

    def _collect_required_dynamic_arguments(
        self, requires: Dict[object, object], resolver: Resolver, queue: QueueScheduler
    ) -> abc.Mapping[str, object]:
        """
        Part of the execute flow: returns values for kwargs and the inverse relation derived from the lhs for which this
        constructor is the rhs, if appliccable.
        """
        type_class = self.type
        assert type_class

        # kwargs
        kwarg_attrs: dict[str, object] = {}
        for kwargs in self.wrapped_kwargs:
            for k, v in kwargs.execute(requires, resolver, queue):
                if k in self.attributes or k in kwarg_attrs:
                    raise RuntimeException(
                        self, "The attribute %s is set twice in the constructor call of %s." % (k, self.class_type)
                    )
                attribute = type_class.get_attribute(k)
                if attribute is None:
                    raise TypingException(self, "no attribute %s on type %s" % (k, type_class.get_full_name()))
                kwarg_attrs[k] = v

        lhs_inverse_assignment: Optional[tuple[str, object]] = None
        if self._lhs_attribute is not None:
            lhs_instance: object = self._lhs_attribute.instance.execute(requires, resolver, queue)
            if not isinstance(lhs_instance, Instance):
                raise Exception("Invalid state: received lhs_attribute that is not an instance")
            lhs_attribute: Optional[Attribute] = lhs_instance.get_type().get_attribute(self._lhs_attribute.attribute)
            if not isinstance(lhs_attribute, RelationAttribute):
                raise RuntimeException(
                    self,
                    (
                        f"Attempting to assign constructor of type {type_class} to attribute that is not a relation attribute:"
                        f" {lhs_attribute} on {lhs_instance}"
                    ),
                )
            inverse: Optional[RelationAttribute] = lhs_attribute.end
            if (
                inverse is not None
                and inverse.name not in self._direct_attributes
                and inverse.name not in kwarg_attrs
                and inverse.name in chain.from_iterable(type_class.get_indices())
                and (inverse.entity == type_class or type_class.is_parent(inverse.entity))
            ):
                lhs_inverse_assignment = (inverse.name, lhs_instance)

        late_args = {**dict([lhs_inverse_assignment] if lhs_inverse_assignment is not None else []), **kwarg_attrs}
        missing_attrs: abc.Sequence[str] = [attr for attr in self._required_dynamic_args if attr not in late_args]
        if missing_attrs:
            raise IndexAttributeMissingInConstructorException(self, type_class, missing_attrs)
        return late_args

    def execute(self, requires: Dict[object, object], resolver: Resolver, queue: QueueScheduler) -> Instance:
        """
        Evaluate this statement.
        """
        LOGGER.log(LOG_LEVEL_TRACE, "executing constructor for %s at %s", self.class_type, self.location)
        super().execute(requires, resolver, queue)

        type_class = self.type
        assert type_class

        late_args: abc.Mapping[str, object] = self._collect_required_dynamic_arguments(requires, resolver, queue)

        direct_attributes: Dict[str, object] = {
            k: v.execute(requires, resolver, queue) for (k, v) in self._direct_attributes.items()
        }
        direct_attributes.update(late_args)

        indirect_attributes: Dict[str, ExpressionStatement] = {
            k: v for k, v in self._indirect_attributes.items() if k not in late_args
        }

        instances: List[Instance] = []
        collisions: abc.MutableMapping[tuple[str, ...], Instance] = {}
        for index in type_class.get_indices():
            params = []
            for attr in index:
                params.append((attr, direct_attributes[attr]))

            obj: Optional[Instance] = type_class.lookup_index(params, self)

            if obj is not None:
                if obj.get_type() != type_class:
                    raise DuplicateException(self, obj, "Type found in index is not an exact match")
                instances.append(obj)
                collisions[tuple(index)] = obj

        object_instance: Instance
        graph: Optional[DataflowGraph] = resolver.dataflow_graph
        if len(instances) > 0:
            if graph is not None:
                graph.add_index_match(
                    chain(
                        [self.get_dataflow_node(graph)],
                        (i.instance_node for i in instances if i.instance_node is not None),
                    )
                )

            first = instances[0]
            for i in instances[1:]:
                if i != first:
                    raise IndexCollisionException(
                        msg=("Inconsistent indexes detected!\n"),
                        constructor=self,
                        collisions=collisions,
                    )

            object_instance = first
            self.copy_location(object_instance)
            for k, v in direct_attributes.items():
                object_instance.set_attribute(k, v, self.location)
        else:
            object_instance = type_class.get_instance(
                direct_attributes, resolver, queue, self.location, self.get_dataflow_node(graph) if graph is not None else None
            )

        self_var: ResultVariable[Instance] = ResultVariable()
        self_var.set_value(object_instance, self.location)
        self_resolver: VariableResolver = VariableResolver(resolver, self._self_ref.name, self_var)
        for attributename, valueexpression in indirect_attributes.items():
            var = object_instance.get_attribute(attributename)
            if var.is_multi():
                reqs = valueexpression.requires_emit_gradual(
                    self_resolver, queue, GradualSetAttributeHelper(self, object_instance, attributename, var)
                )
            else:
                reqs = valueexpression.requires_emit(self_resolver, queue)
            SetAttributeHelper(queue, self_resolver, var, reqs, valueexpression, self, object_instance, attributename)

        for stmt in type_class.get_sub_constructor():
            stmt.emit(object_instance, queue)

        object_instance.trackers.append(queue.get_tracker())

        return object_instance

    def add_attribute(self, lname: LocatableString, value: ExpressionStatement) -> None:
        """
        Add an attribute to this constructor call
        """
        name = str(lname)
        if name not in self.__attributes:
            self.__attributes[name] = value
            self.__attribute_locations[name] = lname
            self.anchors.append(AttributeReferenceAnchor(lname.get_location(), lname.namespace, self.class_type, name))
            self.anchors.extend(value.get_anchors())
        else:
            raise RuntimeException(
                self, "The attribute %s in the constructor call of %s is already set." % (name, self.class_type)
            )
