# Stubs for asyncpg.connection (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.
from asyncpg.cursor import CursorFactory
from asyncpg.prepared_stmt import PreparedStatement
from asyncpg.protocol import Record

from . import connect_utils
from asyncpg.transaction import Transaction
from collections import namedtuple
from typing import Any, Optional, List, AsyncIterator


class ConnectionMeta(type):
    def __instancecheck__(cls, instance: Any): ...

class Connection(metaclass=ConnectionMeta):
    def __init__(self, protocol: Any, transport: Any, loop: Any, addr: None, config: connect_utils._ClientConfiguration,
                 params: connect_utils._ConnectionParameters) -> None: ...
    def __del__(self) -> None: ...
    async def add_listener(self, channel: Any, callback: Any) -> None: ...
    async def remove_listener(self, channel: Any, callback: Any) -> None: ...
    def add_log_listener(self, callback: Any) -> None: ...
    def remove_log_listener(self, callback: Any) -> None: ...
    def get_server_pid(self): ...
    def get_server_version(self): ...
    def get_settings(self): ...
    def transaction(self, *, isolation: str = ..., readonly: bool = ..., deferrable: bool = ...) -> Transaction: ...
    def is_in_transaction(self) -> bool: ...
    async def execute(self, query: str, *args: Any, timeout: float=...) -> str: ...
    async def executemany(self, command: str, args: Any, *, timeout: float=...) -> None: ...
    def cursor(self, query: Any, *args: Any, prefetch: Optional[Any] = ..., timeout: Optional[Any] = ...) -> AsyncIterator[Record]: ...
    async def prepare(self, query: str, *, timeout: Optional[float] = ...) -> PreparedStatement: ...
    async def fetch(self, query: str, *args: Any, timeout: Any=...) -> List[Record]: ...
    async def fetchval(self, query: str, *args: Any, column: int = ..., timeout: Optional[float] = ...) -> Optional[Any]: ...
    async def fetchrow(self, query: str, *args: Any, timeout: Optional[float] = ...) -> Optional[Record]: ...
    async def copy_from_table(self, table_name: str, output: Any, *, columns: Optional[List[str]] = ..., schema_name: Optional[str] = ..., timeout: Optional[float] = ..., format: Optional[Any] = ..., oids: Optional[Any] = ..., delimiter: Optional[Any] = ..., null: Optional[Any] = ..., header: Optional[Any] = ..., quote: Optional[Any] = ..., escape: Optional[Any] = ..., force_quote: Optional[Any] = ..., encoding: Optional[Any] = ...) -> str: ...
    async def copy_from_query(self, query: str, *args: Any, output: Any, timeout: Optional[float] = ..., format: Optional[Any] = ..., oids: Optional[Any] = ..., delimiter: Optional[Any] = ..., null: Optional[Any] = ..., header: Optional[Any] = ..., quote: Optional[Any] = ..., escape: Optional[Any] = ..., force_quote: Optional[Any] = ..., encoding: Optional[Any] = ...) -> str: ...
    async def copy_to_table(self, table_name: str, source: Any, *, columns: Optional[str] = ..., schema_name: Optional[str] = ..., timeout: Optional[float] = ..., format: Optional[Any] = ..., oids: Optional[Any] = ..., freeze: Optional[Any] = ..., delimiter: Optional[Any] = ..., null: Optional[Any] = ..., header: Optional[Any] = ..., quote: Optional[Any] = ..., escape: Optional[Any] = ..., force_quote: Optional[Any] = ..., force_not_null: Optional[Any] = ..., force_null: Optional[Any] = ..., encoding: Optional[Any] = ...) -> str: ...
    async def copy_records_to_table(self, table_name: str, records: Any, *, columns: Optional[List[str]] = ..., schema_name: Optional[str] = ..., timeout: Optional[float] = ...) -> str: ...
    async def set_type_codec(self, typename: str, *, schema: str = ..., encoder: Any, decoder: Any, format: str = ...) -> None: ...
    async def reset_type_codec(self, typename: str, *, schema: str = ...) -> None: ...
    async def set_builtin_type_codec(self, typename: str, *, schema: str = ..., codec_name: str, format: Optional[Any] = ...) -> None: ...
    def is_closed(self) -> bool: ...
    async def close(self, *, timeout: Optional[float] = ...) -> None: ...
    def terminate(self) -> None: ...
    async def reset(self, *, timeout: Optional[float] = ...) -> None: ...
    async def reload_schema_state(self) -> None: ...

async def connect(dsn: Optional[Any] = ..., *, host: Optional[Any] = ..., port: Optional[Any] = ..., user: Optional[Any] = ..., password: Optional[Any] = ..., passfile: Optional[Any] = ..., database: Optional[Any] = ..., loop: Optional[Any] = ..., timeout: int = ..., statement_cache_size: int = ..., max_cached_statement_lifetime: int = ..., max_cacheable_statement_size: Any = ..., command_timeout: Optional[Any] = ..., ssl: Optional[Any] = ..., connection_class: Any = ..., server_settings: Optional[Any] = ...): ...

class _StatementCacheEntry:
    def __init__(self, cache: Any, query: Any, statement: Any) -> None: ...

class _StatementCache:
    def __init__(self, loop: Any, max_size: Any, on_remove: Any, max_lifetime: Any) -> None: ...
    def __len__(self): ...
    def get_max_size(self): ...
    def set_max_size(self, new_size: Any) -> None: ...
    def get_max_lifetime(self): ...
    def set_max_lifetime(self, new_lifetime: Any) -> None: ...
    def get(self, query: Any, *, promote: bool = ...): ...
    def has(self, query: Any): ...
    def put(self, query: Any, statement: Any) -> None: ...
    def iter_statements(self): ...
    def clear(self) -> None: ...

class _Atomic:
    def __init__(self) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, t: Any, e: Any, tb: Any) -> None: ...

class _ConnectionProxy: ...

ServerCapabilities = namedtuple('ServerCapabilities', ['advisory_locks', 'notifications', 'plpgsql', 'sql_reset', 'sql_close_all'])
