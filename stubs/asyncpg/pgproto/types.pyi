import builtins
import typing
from typing import Any, SupportsIndex

class BitString:
    def __init__(self, bitstring: typing.Optional[builtins.bytes] = ...) -> None: ...
    @classmethod
    def frombytes(cls, bytes_: typing.Optional[builtins.bytes] = ..., bitlength: typing.Optional[int] = ...) -> "BitString": ...
    @property
    def bytes(self) -> builtins.bytes: ...
    def as_string(self) -> str: ...
    def to_int(self, bitorder: object = ..., *, signed: bool = ...) -> int: ...
    @classmethod
    def from_int(cls, x: int, length: int, bitorder: object = ..., *, signed: bool = ...) -> "BitString": ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __getitem__(self, i: int) -> int: ...
    def __len__(self) -> int: ...

class Point(typing.Tuple[float, float]):
    def __new__(cls, x: typing.Union[typing.SupportsFloat, SupportsIndex, typing.Text, builtins.bytes, builtins.bytearray], y: typing.Union[typing.SupportsFloat, SupportsIndex, typing.Text, builtins.bytes, builtins.bytearray]) -> Point: ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...

class Box(typing.Tuple[Point, Point]):
    def __new__(cls, high: typing.Sequence[float], low: typing.Sequence[float]) -> Box: ...
    @property
    def high(self) -> Point: ...
    @property
    def low(self) -> Point: ...

class Line(typing.Tuple[float, float, float]):
    def __new__(cls, A: float, B: float, C: float) -> Line: ...
    @property
    def A(self) -> float: ...
    @property
    def B(self) -> float: ...
    @property
    def C(self) -> float: ...

class LineSegment(typing.Tuple[Point, Point]):
    def __new__(cls, p1: typing.Sequence[float], p2: typing.Sequence[float]) -> LineSegment: ...
    @property
    def p1(self) -> Point: ...
    @property
    def p2(self) -> Point: ...

class Path:
    points: Any
    def __init__(self, *points: typing.Sequence[float], is_closed: bool = ...) -> None: ...
    @property
    def is_closed(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[Point]: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, i: int) -> Point: ...
    @typing.overload
    def __getitem__(self, i: slice) -> typing.Tuple[Point, ...]: ...
    def __contains__(self, point: object) -> bool: ...

class Polygon(Path):
    def __init__(self, *points: typing.Sequence[float]) -> None: ...

class Circle(typing.Tuple[Point, float]):
    def __new__(cls, center: Point, radius: float) -> Circle: ...
    @property
    def center(self) -> Point: ...
    @property
    def radius(self) -> float: ...
