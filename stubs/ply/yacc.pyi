# Stubs for ply.yacc (Python 3.7)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional, TypeVar, Generic, List

from ply.lex import Lexer

__tabversion__: str
yaccdebug: bool
debug_file: str
tab_module: str
default_lr: str
error_count: int
yaccdevel: bool
resultlimit: int
pickle_protocol: int
string_types = str
MAXINT: Any

class PlyLogger:
    f: Any = ...
    def __init__(self, f: Any) -> None: ...
    def debug(self, msg: Any, *args: Any, **kwargs: Any) -> None: ...
    info: Any = ...
    def warning(self, msg: Any, *args: Any, **kwargs: Any) -> None: ...
    def error(self, msg: Any, *args: Any, **kwargs: Any) -> None: ...
    critical: Any = ...

class NullLogger: ...

class YaccError(Exception): ...

class YaccSymbol: ...

class YaccProduction:
    slice: Any = ...
    stack: Any = ...
    lexer: Lexer = ...
    parser: Any = ...
    value: str
    type: str
    def __init__(self, s: Any, stack: Optional[Any] = ...) -> None: ...
    def __getitem__(self, n: Any) -> Any: ...
    def __setitem__(self, n: Any, v: Any) -> None: ...
    def __len__(self) -> int: ...
    def lineno(self, n: Any) -> int: ...
    def set_lineno(self, n: Any, lineno: Any) -> None: ...
    def lexpos(self, n: Any) -> int: ...
    def set_lexpos(self, n: Any, lexpos: Any) -> None: ...
    def error(self) -> None: ...


class LRParser:
    productions: Any = ...
    action: Any = ...
    goto: Any = ...
    errorfunc: Any = ...
    errorok: bool = ...
    def __init__(self, lrtab: Any, errorf: Any) -> None: ...
    def errok(self) -> None: ...
    def restart(self) -> None: ...
    defaulted_states: Any = ...
    def set_defaulted_states(self) -> None: ...
    def disable_defaulted_states(self) -> None: ...
    def parse(self, input: Optional[Any] = ..., lexer: Optional[Any] = ..., debug: bool = ..., tracking: bool = ..., tokenfunc: Optional[Any] = ...) -> List[object]: ...
    token: Any = ...
    statestack: Any = ...
    symstack: Any = ...
    state: Any = ...


class Production:
    reduced: int = ...
    name: Any = ...
    prod: Any = ...
    number: Any = ...
    func: Any = ...
    callable: Any = ...
    file: Any = ...
    line: Any = ...
    prec: Any = ...
    len: Any = ...
    usyms: Any = ...
    lr_items: Any = ...
    lr_next: Any = ...
    str: Any = ...
    def __init__(self, number: Any, name: Any, prod: Any, precedence: Any = ..., func: Optional[Any] = ..., file: str = ..., line: int = ...) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: Any) -> Any: ...
    def bind(self, pdict: Any) -> None: ...

class MiniProduction:
    name: Any = ...
    len: Any = ...
    func: Any = ...
    callable: Any = ...
    file: Any = ...
    line: Any = ...
    str: Any = ...
    def __init__(self, str: Any, name: Any, len: Any, func: Any, file: Any, line: Any) -> None: ...
    def bind(self, pdict: Any) -> None: ...

class LRItem:
    name: Any = ...
    prod: Any = ...
    number: Any = ...
    lr_index: Any = ...
    lookaheads: Any = ...
    len: Any = ...
    usyms: Any = ...
    def __init__(self, p: Any, n: Any) -> None: ...

class GrammarError(YaccError): ...

class Grammar:
    Productions: Any = ...
    Prodnames: Any = ...
    Prodmap: Any = ...
    Terminals: Any = ...
    Nonterminals: Any = ...
    First: Any = ...
    Follow: Any = ...
    Precedence: Any = ...
    UsedPrecedence: Any = ...
    Start: Any = ...
    def __init__(self, terminals: Any) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: Any) -> Any: ...
    def set_precedence(self, term: Any, assoc: Any, level: Any) -> None: ...
    def add_production(self, prodname: Any, syms: Any, func: Optional[Any] = ..., file: str = ..., line: int = ...) -> None: ...
    def set_start(self, start: Optional[Any] = ...) -> None: ...
    def build_lritems(self) -> None: ...

class VersionError(YaccError): ...

class LRTable:
    lr_action: Any = ...
    lr_goto: Any = ...
    lr_productions: Any = ...
    lr_method: Any = ...
    def __init__(self) -> None: ...
    def bind_callables(self, pdict: Any) -> None: ...

def traverse(x: Any, N: Any, stack: Any, F: Any, X: Any, R: Any, FP: Any) -> None: ...

class LALRError(YaccError): ...

class LRGeneratedTable(LRTable):
    grammar: Any = ...
    lr_method: Any = ...
    log: Any = ...
    lr_action: Any = ...
    lr_goto: Any = ...
    lr_productions: Any = ...
    lr_goto_cache: Any = ...
    lr0_cidhash: Any = ...
    sr_conflict: int = ...
    rr_conflict: int = ...
    conflicts: Any = ...
    sr_conflicts: Any = ...
    rr_conflicts: Any = ...
    def __init__(self, grammar: Any, method: str = ..., log: Optional[Any] = ...) -> None: ...
    def add_lookaheads(self, lookbacks: Any, followset: Any) -> None: ...
    def add_lalr_lookaheads(self, C: Any) -> None: ...
    def lr_parse_table(self) -> None: ...
    def write_table(self, tabmodule: Any, outputdir: str = ..., signature: str = ...) -> None: ...
    def pickle_table(self, filename: Any, signature: str = ...) -> None: ...

class ParserReflect:
    pdict: Any = ...
    start: Any = ...
    error_func: Any = ...
    tokens: Any = ...
    modules: Any = ...
    grammar: Any = ...
    error: bool = ...
    log: Any = ...
    def __init__(self, pdict: Any, log: Optional[Any] = ...) -> None: ...
    def get_all(self) -> None: ...
    def validate_modules(self) -> None: ...
    def get_start(self) -> None: ...
    def validate_start(self) -> None: ...
    def get_error_func(self) -> None: ...
    prec: Any = ...
    def get_precedence(self) -> None: ...
    preclist: Any = ...
    pfuncs: Any = ...


def yacc(
    method: str = ...,
    debug: Any = ...,
    module: Optional[Any] = ...,
    tabmodule: Any = ...,
    start: Optional[Any] = ...,
    check_recursion: bool = ...,
    optimize: bool = ...,
    write_tables: bool = ...,
    debugfile: Any = ...,
    outputdir: Optional[Any] = ...,
    debuglog: Optional[Any] = ...,
    errorlog: Optional[Any] = ...,
    picklefile: Optional[Any] = ...
) -> LRParser: ...
