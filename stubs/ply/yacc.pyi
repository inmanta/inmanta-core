# Stubs for ply.yacc (Python 3.7)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional

from stubs.ply.lex import Lexer

__tabversion__: str
yaccdebug: bool
debug_file: str
tab_module: str
default_lr: str
error_count: int
yaccdevel: bool
resultlimit: int
pickle_protocol: int
string_types = str
MAXINT: Any

class PlyLogger:
    f: Any = ...
    def __init__(self, f: Any) -> None: ...
    def debug(self, msg: Any, *args: Any, **kwargs: Any) -> None: ...
    info: Any = ...
    def warning(self, msg: Any, *args: Any, **kwargs: Any) -> None: ...
    def error(self, msg: Any, *args: Any, **kwargs: Any) -> None: ...
    critical: Any = ...

class NullLogger:
    def __getattribute__(self, name: Any): ...
    def __call__(self, *args: Any, **kwargs: Any): ...

class YaccError(Exception): ...

def format_result(r: Any): ...
def format_stack_entry(r: Any): ...
def errok(): ...
def restart(): ...
def token(): ...
def call_errorfunc(errorfunc: Any, token: Any, parser: Any): ...

class YaccSymbol: ...

class YaccProduction:
    slice: Any = ...
    stack: Any = ...
    lexer: Lexer = ...
    parser: Any = ...
    value: str
    type: str
    def __init__(self, s: Any, stack: Optional[Any] = ...) -> None: ...
    def __getitem__(self, n: Any): ...
    def __setitem__(self, n: Any, v: Any) -> None: ...
    def __getslice__(self, i: Any, j: Any): ...
    def __len__(self): ...
    def lineno(self, n: Any): ...
    def set_lineno(self, n: Any, lineno: Any) -> None: ...
    def linespan(self, n: Any): ...
    def lexpos(self, n: Any): ...
    def set_lexpos(self, n: Any, lexpos: Any) -> None: ...
    def lexspan(self, n: Any): ...
    def error(self) -> None: ...

class LRParser:
    productions: Any = ...
    action: Any = ...
    goto: Any = ...
    errorfunc: Any = ...
    errorok: bool = ...
    def __init__(self, lrtab: Any, errorf: Any) -> None: ...
    def errok(self) -> None: ...
    def restart(self) -> None: ...
    defaulted_states: Any = ...
    def set_defaulted_states(self) -> None: ...
    def disable_defaulted_states(self) -> None: ...
    def parse(self, input: Optional[Any] = ..., lexer: Optional[Any] = ..., debug: bool = ..., tracking: bool = ..., tokenfunc: Optional[Any] = ...): ...
    token: Any = ...
    statestack: Any = ...
    symstack: Any = ...
    state: Any = ...
    def parsedebug(self, input: Optional[Any] = ..., lexer: Optional[Any] = ..., debug: bool = ..., tracking: bool = ..., tokenfunc: Optional[Any] = ...): ...
    def parseopt(self, input: Optional[Any] = ..., lexer: Optional[Any] = ..., debug: bool = ..., tracking: bool = ..., tokenfunc: Optional[Any] = ...): ...
    def parseopt_notrack(self, input: Optional[Any] = ..., lexer: Optional[Any] = ..., debug: bool = ..., tracking: bool = ..., tokenfunc: Optional[Any] = ...): ...

class Production:
    reduced: int = ...
    name: Any = ...
    prod: Any = ...
    number: Any = ...
    func: Any = ...
    callable: Any = ...
    file: Any = ...
    line: Any = ...
    prec: Any = ...
    len: Any = ...
    usyms: Any = ...
    lr_items: Any = ...
    lr_next: Any = ...
    str: Any = ...
    def __init__(self, number: Any, name: Any, prod: Any, precedence: Any = ..., func: Optional[Any] = ..., file: str = ..., line: int = ...) -> None: ...
    def __len__(self): ...
    def __nonzero__(self): ...
    def __getitem__(self, index: Any): ...
    def lr_item(self, n: Any): ...
    def bind(self, pdict: Any) -> None: ...

class MiniProduction:
    name: Any = ...
    len: Any = ...
    func: Any = ...
    callable: Any = ...
    file: Any = ...
    line: Any = ...
    str: Any = ...
    def __init__(self, str: Any, name: Any, len: Any, func: Any, file: Any, line: Any) -> None: ...
    def bind(self, pdict: Any) -> None: ...

class LRItem:
    name: Any = ...
    prod: Any = ...
    number: Any = ...
    lr_index: Any = ...
    lookaheads: Any = ...
    len: Any = ...
    usyms: Any = ...
    def __init__(self, p: Any, n: Any) -> None: ...

def rightmost_terminal(symbols: Any, terminals: Any): ...

class GrammarError(YaccError): ...

class Grammar:
    Productions: Any = ...
    Prodnames: Any = ...
    Prodmap: Any = ...
    Terminals: Any = ...
    Nonterminals: Any = ...
    First: Any = ...
    Follow: Any = ...
    Precedence: Any = ...
    UsedPrecedence: Any = ...
    Start: Any = ...
    def __init__(self, terminals: Any) -> None: ...
    def __len__(self): ...
    def __getitem__(self, index: Any): ...
    def set_precedence(self, term: Any, assoc: Any, level: Any) -> None: ...
    def add_production(self, prodname: Any, syms: Any, func: Optional[Any] = ..., file: str = ..., line: int = ...) -> None: ...
    def set_start(self, start: Optional[Any] = ...) -> None: ...
    def find_unreachable(self): ...
    def infinite_cycles(self): ...
    def undefined_symbols(self): ...
    def unused_terminals(self): ...
    def unused_rules(self): ...
    def unused_precedence(self): ...
    def compute_first(self): ...
    def compute_follow(self, start: Optional[Any] = ...): ...
    def build_lritems(self) -> None: ...

class VersionError(YaccError): ...

class LRTable:
    lr_action: Any = ...
    lr_goto: Any = ...
    lr_productions: Any = ...
    lr_method: Any = ...
    def __init__(self) -> None: ...
    def read_table(self, module: Any): ...
    def read_pickle(self, filename: Any): ...
    def bind_callables(self, pdict: Any) -> None: ...

def digraph(X: Any, R: Any, FP: Any): ...
def traverse(x: Any, N: Any, stack: Any, F: Any, X: Any, R: Any, FP: Any) -> None: ...

class LALRError(YaccError): ...

class LRGeneratedTable(LRTable):
    grammar: Any = ...
    lr_method: Any = ...
    log: Any = ...
    lr_action: Any = ...
    lr_goto: Any = ...
    lr_productions: Any = ...
    lr_goto_cache: Any = ...
    lr0_cidhash: Any = ...
    sr_conflict: int = ...
    rr_conflict: int = ...
    conflicts: Any = ...
    sr_conflicts: Any = ...
    rr_conflicts: Any = ...
    def __init__(self, grammar: Any, method: str = ..., log: Optional[Any] = ...) -> None: ...
    def lr0_closure(self, I: Any): ...
    def lr0_goto(self, I: Any, x: Any): ...
    def lr0_items(self): ...
    def compute_nullable_nonterminals(self): ...
    def find_nonterminal_transitions(self, C: Any): ...
    def dr_relation(self, C: Any, trans: Any, nullable: Any): ...
    def reads_relation(self, C: Any, trans: Any, empty: Any): ...
    def compute_lookback_includes(self, C: Any, trans: Any, nullable: Any): ...
    def compute_read_sets(self, C: Any, ntrans: Any, nullable: Any): ...
    def compute_follow_sets(self, ntrans: Any, readsets: Any, inclsets: Any): ...
    def add_lookaheads(self, lookbacks: Any, followset: Any) -> None: ...
    def add_lalr_lookaheads(self, C: Any) -> None: ...
    def lr_parse_table(self) -> None: ...
    def write_table(self, tabmodule: Any, outputdir: str = ..., signature: str = ...) -> None: ...
    def pickle_table(self, filename: Any, signature: str = ...) -> None: ...

def get_caller_module_dict(levels: Any): ...
def parse_grammar(doc: Any, file: Any, line: Any): ...

class ParserReflect:
    pdict: Any = ...
    start: Any = ...
    error_func: Any = ...
    tokens: Any = ...
    modules: Any = ...
    grammar: Any = ...
    error: bool = ...
    log: Any = ...
    def __init__(self, pdict: Any, log: Optional[Any] = ...) -> None: ...
    def get_all(self) -> None: ...
    def validate_all(self): ...
    def signature(self): ...
    def validate_modules(self) -> None: ...
    def get_start(self) -> None: ...
    def validate_start(self) -> None: ...
    def get_error_func(self) -> None: ...
    def validate_error_func(self): ...
    def get_tokens(self): ...
    def validate_tokens(self): ...
    prec: Any = ...
    def get_precedence(self) -> None: ...
    preclist: Any = ...
    def validate_precedence(self): ...
    pfuncs: Any = ...
    def get_pfunctions(self): ...
    def validate_pfunctions(self): ...

def yacc(method: str = ..., debug: Any = ..., module: Optional[Any] = ..., tabmodule: Any = ..., start: Optional[Any] = ..., check_recursion: bool = ..., optimize: bool = ..., write_tables: bool = ..., debugfile: Any = ..., outputdir: Optional[Any] = ..., debuglog: Optional[Any] = ..., errorlog: Optional[Any] = ..., picklefile: Optional[Any] = ...): ...
